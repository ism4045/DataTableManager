// Fill out your copyright notice in the Description page of Project Settings.


#include "StructGenerator.h"
#include "Misc/FileHelper.h"
#include "HAL/PlatformFileManager.h"

using namespace OpenXLSX;
using namespace std;

StructGenerator::StructGenerator()
{
}

StructGenerator::~StructGenerator()
{
}

bool StructGenerator::GenerateStructFromXlsx(const FString& InXlsxFilePath, const FString& InCSVFolderPath, const FString& OutStructFolderPath)
{
	XLDocument Doc;
	Doc.open(TCHAR_TO_UTF8(*InXlsxFilePath));
	if (Doc.isOpen() == false)
	{
		UE_LOG(LogTemp, Error, TEXT("Failed to Open Excel File"));
		return false;
	}

	string HeaderName = Doc.name();
	HeaderName.erase(HeaderName.end() - 5, HeaderName.end());
	ofstream HeaderFile(*FPaths::Combine(OutStructFolderPath, (HeaderName + ".h").c_str()));
	if (HeaderFile.fail())
	{
		UE_LOG(LogTemp, Error, TEXT("Please check if Struct and Public folders exist"));
		return false;
	}

	WriteBasicInformation(HeaderFile);
	WriteInclude(HeaderFile, HeaderName);
	WriteStruct(HeaderFile, Doc, InCSVFolderPath);

	HeaderFile.close();
	Doc.close();

	UE_LOG(LogTemp, Display, TEXT("Success Generate Struct"));
	return true;
}

bool StructGenerator::WriteBasicInformation(std::ofstream& InOpenedFile)
{
	InOpenedFile << "// Copyright Epic Games, Inc. All Rights Reserved." << endl;
	InOpenedFile << "// Generated by Lee HoSoung." << endl;
	InOpenedFile << "// It is auto generated header file." << endl;
	InOpenedFile << "// Please do not edit" << endl << endl;

	return true;
}

bool StructGenerator::WriteInclude(std::ofstream& InOpenedFile, const std::string& InHeaderName)
{
	InOpenedFile << "#pragma once" << endl << endl;
	InOpenedFile << "#include \"CoreMinimal.h\"" << endl;
	InOpenedFile << "#include \"Engine/DataTable.h\"" << endl;
	InOpenedFile << "#include \"" + InHeaderName + ".generated.h\"" << endl << endl;

	return true;
}

bool StructGenerator::WriteStruct(std::ofstream& InOpenedFile, OpenXLSX::XLDocument& InOpenedDoc, const FString& InCSVFolderPath)
{
	vector<string> WorkSheetNames = InOpenedDoc.workbook().worksheetNames();

	for (int Num1 = 0; Num1 < WorkSheetNames.size(); Num1++)
	{
		XLWorksheet Wks = InOpenedDoc.workbook().worksheet(WorkSheetNames[Num1]);
		
		FString FileContent;
		FString CSVPath = FPaths::ConvertRelativePathToFull(InCSVFolderPath);
		FFileHelper::LoadFileToString(FileContent, *FPaths::Combine(CSVPath, Wks.name().append(".csv").c_str()));

		TArray<FString> Lines, VarNames, VarTypes;
		FileContent.ParseIntoArrayLines(Lines);

		if (Lines.Num() < 2)
		{
			return false;
		}

		Lines[0].ParseIntoArray(VarTypes, TEXT(","));
		Lines[1].ParseIntoArray(VarNames, TEXT(","));

		if (VarTypes.Num() < 2 || VarNames.Num() < 2 || VarNames.Num() != VarTypes.Num())
		{
			return false;
		}

		InOpenedFile << "USTRUCT(BlueprintType)" << endl;
		InOpenedFile << "struct " << "F" << Wks.name() << " : public FTableRowBase" << endl;
		InOpenedFile << "{" << endl;
		InOpenedFile << "    GENERATED_BODY()" << endl << endl;

		for (int Num2 = 1; Num2 < VarNames.Num(); Num2++)
		{
			FString UnrealType = GetUnrealType(VarTypes[Num2]);

			InOpenedFile << "	UPROPERTY(EditAnywhere, BlueprintReadWrite)" << endl;
			InOpenedFile << "	" << string(TCHAR_TO_UTF8(*UnrealType)) << " " << string(TCHAR_TO_UTF8(*VarNames[Num2])) << ";" << endl << endl;
		}

		InOpenedFile << "};" << endl;
	}

	return true;
}

FString StructGenerator::GetUnrealType(const FString& InVarType)
{
	FString VarTypeLower = InVarType.ToLower();

	if (VarTypeLower == "long double")
	{
		return "double";
	}
	else if (VarTypeLower == "string" || VarTypeLower == "fstring")
	{
		return "FString";
	}
	else if (VarTypeLower == "text" || VarTypeLower == "ftext")
	{
		return "FText";
	}

	return InVarType;
}
